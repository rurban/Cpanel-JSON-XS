{"version":1,"ops":[{"type":3,"author":{"id":"a79d2c1d397f6d19981d400fda93180b1c5f5a5c"},"timestamp":1553234038,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NTUwMjk5OQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-475502999"},"message":"Yep, https://metacpan.org/pod/Cpanel::JSON::XS#BOM describes that it can `accept and decode a BOM` but doesn't go into enough detail about what happens after (it does mention throwing errors, but not about the state of the Cpanel::JSON::XS object upon encountering the BOM.)\n\nGiven that RFC7159 was quoted as well, it probably would be better to keep in line with that and ignore/filter out BOMs from anywhere in the text source entirely.","files":null},{"type":5,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553255664,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDIyMjI0MDg0MDU="},"added":["bug"],"removed":[]},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553255707,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NTU5MzA3OQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-475593079"},"message":"Hmm, I have to think about how to detect such instances. Good testcase","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553284287,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NTc1ODMwOA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-475758308"},"message":"The description for BOM handling is referencing the outdated RFC7159, though the handling of BOM hasn't changed. RFC8259 is newer and says:\n```\n   JSON text exchanged between systems that are not part of a closed\n   ecosystem MUST be encoded using UTF-8 [RFC3629].\n\n   Previous specifications of JSON have not required the use of UTF-8\n   when transmitting JSON text.  However, the vast majority of JSON-\n   based software implementations have chosen to use the UTF-8 encoding,\n   to the extent that it is the only encoding that achieves\n   interoperability.\n\n   Implementations MUST NOT add a byte order mark (U+FEFF) to the\n   beginning of a networked-transmitted JSON text.  In the interests of\n   interoperability, implementations that parse JSON texts MAY ignore\n   the presence of a byte order mark rather than treating it as an\n   error.\n```\nhttps://tools.ietf.org/html/rfc8259#section-8.1","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553284402,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NTc1ODczNQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-475758735"},"message":"I also believe this BOM handling was originally added for these testcases, I wonder if it's that important. https://github.com/rurban/Cpanel-JSON-XS/issues/72","files":null},{"type":6,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553284402,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDIwMDA2MTU0OQ=="},"target":"22896a15c1063b4a12d301628d03d5014244ec5c691fc1416e3e6096a5e955fb","message":"I also believe this BOM handling was originally added for these testcases, I wonder if it's that important to do anything other than ignore the BOM. https://github.com/rurban/Cpanel-JSON-XS/issues/72","files":null},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553586322,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NjUxMDM4MA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476510380"},"message":"\u003e RFC8259 is newer \nOne minor comment in this: RFC8259 being newer doesn't mean it's necessarily better. The very first RFC is still the best and secure, the 2nd started adding insecurities, and the third didn't clarify at all the glaring open problems (such as dupkeys), it just declared BOM's or other implicit encodings wrong. Nobody takes them too serious as the cat is already out of the bag. And the clarifications didn't help, they made it even worse.","files":null},{"type":6,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553586322,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDIwMTA5MTY5Mg=="},"target":"2c21ac5747be550c45e9bbbd607768078e546622e027e46d7335044a1891a837","message":"\u003e RFC8259 is newer \n\nOne minor comment in this: RFC8259 being newer doesn't mean it's necessarily better. The very first RFC is still the best and secure, the 2nd started adding insecurities, and the third didn't clarify at all the glaring open problems (such as dupkeys), it just declared BOM's or other implicit encodings wrong. Nobody takes them too serious as the cat is already out of the bag. And the clarifications didn't help, they made it even worse.","files":null},{"type":6,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553589607,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDIwMTExMjg1Mw=="},"target":"2c21ac5747be550c45e9bbbd607768078e546622e027e46d7335044a1891a837","message":"\u003e RFC8259 is newer \n\nOne minor comment in this: RFC8259 being newer doesn't mean it's necessarily better. The very first RFC is still the best and secure, the 2nd started adding insecurities, and the third didn't clarify at all the glaring open problems (such as dupkeys), it just declared BOM's or other implicit encodings wrong. Nobody takes them too serious as the cat is already out of the bag. You can only add features, not take them back later. And the clarifications didn't help, they made it even worse.","files":null},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553589544,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NjUyNTM3OQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476525379"},"message":"I've fixed it now to restore the BOM-set utf8 flag after each decode call and added to the documentation:\n\n*The BOM encoding is set only for one specific decode call, it does not\nchange the state of the JSON object.*\n\nThis way we can avoid keeping the global decoding pos in the object (like we do with incr_pos). \nThe BOM encoding is still set at the beginning of each decode call, because we have no document or streaming support. But it's then reverted after the call.\nWe only deal with strings, which can be in the middle of any line-wise processed document or stream.\n\nWe could add a new **disallow_bom** flag if this becomes too troublesome, but I doubt so. Those BOM's are a rarity in normal strings.","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553612513,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NjY4OTYxNw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476689617"},"message":"There is still the mentioned issue that finding the (decoded) BOM should not enable utf8 at all. The text is already decoded.","files":null},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553613837,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NjcwMDU4OA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476700588"},"message":"`$json-\u003edecode(\"\\x{feff}\" . $as_json)` does enable utf8 for $as_json. Any BOM is honored. \nWe follow the BOM parts of RFC7159. Not RFC8259, and not the scalar (allow_nonref) additions of RFC7159. This is all documented.","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553614106,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NjcwMjkxNQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476702915"},"message":"That doesn't make any sense. Enabling utf8 means it decodes from UTF-8 but \\x{feff} is clearly not encoded to any byte encoding, therefore neither is the rest of the string.","files":null},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553618636,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3NjczOTMzOA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476739338"},"message":"This is the very definition of a BOM. Look it up. What we cannot do is checking if it's at the very start of a document or stream. We have no API for that.","files":null},{"type":4,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553618777,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MjIzMDQ1Mjc3MA=="},"status":2},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553618793,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3Njc0MDYwMw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476740603"},"message":"Done with 4.11","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553619054,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3Njc0MjgyOQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476742829"},"message":"RFC7159 says the same thing I quoted above regarding BOMs, it only says that implementations may ignore it, so it does not seem relevant.\n\nA BOM could tell you to decode it from UTF-8 if it was a UTF-8 encoded BOM. But \\x{feff} is not encoded, so decoding it from *anything* is incorrect. The issue is not determining that it was UTF-8 encoded, but assuming the presence of the BOM means it is still encoded.","files":null},{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1553619335,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3Njc0NTAzMQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476745031"},"message":"No. U+FEFF is the UTF16BOM, it assumes the subsequent string to be UTF-16LE encoded. And thus we decode it from UTF-16LE.","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1553619514,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3Njc0NjU1OQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476746559"},"message":"That's not accurate. U+FEFF is the Unicode \"byte order mark\" codepoint, for any encoding. It indicates an encoding only by being encoded to bytes.\n\nAs shown in the original post, \"\\x{feff}\" concatenated with non-byte-encoded JSON should not be decoded as it will fail.","files":null},{"type":3,"author":{"id":"6e728febc9da9b1f9a1428205c132ba8f3bb8aa2"},"timestamp":1553621966,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ3Njc2NTkyMA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/125#issuecomment-476765920"},"message":"Thank you for the fix and updated version!\n\n\u003e No. U+FEFF is the UTF16BOM, it assumes the subsequent string to be UTF-16LE encoded. And thus we decode it from UTF-16LE.\n\nI'm confused by this - I'd take it to mean that you'd expect this to pass?\n\n```\nuse strict;\nuse warnings;\nuse Test::More;\nuse Cpanel::JSON::XS;\nuse Encode;\n\nok(eval { Cpanel::JSON::XS-\u003enew-\u003edecode(\"\\x{feff}\" . Encode::encode(\"UTF16LE\", q({\"example\":\"data\"}))); }, 'can decode BOM-prefixed strings');\ndone_testing;\n```\n\nI'm not a Unicode expert, but the string contains the *codepoint* `0xFEFF`, *not* the bytes `0xFE 0xFF` (which I agree would be the UTF16 BOM). The actual bytes are `0xEF 0xBB 0xBF`, which have nothing to do with UTF16?\n\n@Grinnz If I understand the current code correctly, the behaviour is now \"force on the UTF-8 flag and upgrade (which should be a no-op)\".\n\nAlthough I agree with what you're saying about the BOM and encoding concepts, this codepath can only be triggered when there's a BOM character, so I believe the SvUTF8 flag would *always* have to be set here. i.e. the current code makes assumptions about internal UTF-8 representation (and is doing some unnecessary work) but I don't think it introduces any new failure modes. Will raise a new issue if we run into any strings that break with the BOM prefix.","files":null}]}