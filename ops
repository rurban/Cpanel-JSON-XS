{"version":1,"ops":[{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1578293885,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MTAyNzcyNQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-571027725"},"message":"This policy and code comes from perl5. which treats any 128-255 byte as Latin1. It even converts utf8 to Latin1 automatically if no \u003e255 codepoint is present in the string.","files":null},{"type":5,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1578293899,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI5MjMyNjg1NzU="},"added":["question"],"removed":[]},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579807234,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3NzgzMzU1MA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577833550"},"message":"\u003e without a decode having happened on that input string, there’s no way to know what _character_ is intended with the `\\xff` in the string.\n\nIs is known. Strings in structure passed to `Cpanel::JSON::XS::encode_json` must be in Unicode and output from that function is JSON, byte octets (as per RFC encoded in UTF-8).\n\nTherefore `\"\\xff\"` is treated as Unicode string, it has one Unicode codepoint U+00FF which has UTF-8 representation 0xC3 0xBF (or 0303 0277 in octal). So output `\"\\303\\277\\\"` is correct and matches API definition.\n\nI do not see nothing wrong or incorrect. It is expected and works correctly.","files":null},{"type":3,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579807493,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3NzgzNTQwOQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577835409"},"message":"Yeah when I filed this I misunderstood the intent. I do wish Perl were harder to misuse in this regard, but it is as it is.\n\nThank you.","files":null},{"type":4,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579807494,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50Mjk3NDk2ODE5Mw=="},"status":2},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579807744,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3NzgzNzMwMQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577837301"},"message":"Maybe you have been confused by Latin1 encoding... Latin1 is encoding where every byte has mapping to Unicode via identity function. So Latin1 byte 0xFF is Unicode code point U+FF. Latin1 0xC3 is Unicode Code point U+C3, etc...","files":null},{"type":3,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579808147,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0MDAxMg==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577840012"},"message":"My point of confusion was that I thought UTF8-flagged strings could be reliably regarded as “character strings”, and non-UTF8-flagged strings as “byte strings”. I didn’t realize that sv_utf8_decode() leaves pure-ASCII strings alone rather than UTF8-flagging them.\n\n(It’s particularly odd since Unicode::UTF8 _does_ add the flag.)\n\nI mean to set aside some time to play around with creating an experimental “typed strings” mode to Perl (`use typedstrings;`) which would, within a given block/module, enforce that distinction by making interaction of UTF8-flagged and non-UTF8-flagged strings a failure. Thus far I’ve not found a reason why it _couldn’t_ work, and an ability to distinguish byte vs. character strings intrinsically would be a boon for serialization to, e.g., CBOR or Sereal—implementations of both of which do actually use the UTF8 flag to distinguish byte from character strings.","files":null},{"type":6,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579808147,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MjgzNzgyMg=="},"target":"cb7e20c8505be0c662fd1b69fdc896d74b91c2078eab1c48fba62e824653bdb9","message":"@pali My point of confusion was that I thought UTF8-flagged strings could be reliably regarded as “character strings”, and non-UTF8-flagged strings as “byte strings”. I didn’t realize that sv_utf8_decode() leaves pure-ASCII strings alone rather than UTF8-flagging them.\n\n(It’s particularly odd since Unicode::UTF8 _does_ add the flag.)\n\nI mean to set aside some time to play around with creating an experimental “typed strings” mode to Perl (`use typedstrings;`) which would, within a given block/module, enforce that distinction by making interaction of UTF8-flagged and non-UTF8-flagged strings a failure. Thus far I’ve not found a reason why it _couldn’t_ work, and an ability to distinguish byte vs. character strings intrinsically would be a boon for serialization to, e.g., CBOR or Sereal—implementations of both of which do actually use the UTF8 flag to distinguish byte from character strings.","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1579808423,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0MTc4Mw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577841783"},"message":"\u003e My point of confusion was that I thought UTF8-flagged strings could be reliably regarded as “character strings”, and non-UTF8-flagged strings as “byte strings”. I didn’t realize that sv_utf8_decode() leaves pure-ASCII strings alone rather than UTF8-flagging them.\n\nIt's far further than that, as I think we've discussed; it's easily possible and probable that a program will have a flagged string that is a byte string, or a unflagged string that is a character string (with up to 0xFF characters, at least). Most importantly there are no guarantees to consistency in this matter and the rules have changed between Perl versions. Which all is to emphasize that the UTF8 flag is for internal C-level use only, and the logical distinction you are looking for would need another mechanism.","files":null},{"type":6,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1579808423,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0Mjg0MDM5MA=="},"target":"de2f090dbbd6b5fe70ce4cd63b58ec4f76ffe1cc52131fc3739796910cb46eb3","message":"\u003e My point of confusion was that I thought UTF8-flagged strings could be reliably regarded as “character strings”, and non-UTF8-flagged strings as “byte strings”. I didn’t realize that sv_utf8_decode() leaves pure-ASCII strings alone rather than UTF8-flagging them.\n\nIt's far further than that, as I think we've discussed; it's easily possible and probable that a program will have a flagged string that is a byte string, or a unflagged string that is a character string (with up to U+00FF characters, at least). Most importantly there are no guarantees to consistency in this matter and the rules have changed between Perl versions. Which all is to emphasize that the UTF8 flag is for internal C-level use only, and the logical distinction you are looking for would need another mechanism.","files":null},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579808419,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0MTg2Mg==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577841862"},"message":"UTF8 flag does not say anything about binariness or UTF-8-ness of Perl scalar.\n\nPerl itself can upgrade or downgrade scalar, convert from scalar with UTF8 flag to scalar without UTF8 flag on the fly at any time.\n\nPure perl code should not even treat such flag as it is fully invisible for it.\n\nThis UTF8 flag is just for C/XS code. And it says what is internal representation of scalar: It says if char* buffer is internally encoded in Latin1 or UTF-8.\n\nSo if you have a string only with code points U+00 .. U+FF it can be internally represented in Latin1 encoding and therefore it is storage effective (as using internal UTF-8 encoding where code points in range U+80 .. U+FF would be encoded by two bytes).","files":null},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579808588,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0MzAyOA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577843028"},"message":"\u003e ability to distinguish byte vs. character strings\n\nThis is not possible in Perl.\n\nIf you want to do it, you need to define objects. E.g. you can create `package String` and  `package ByteArray` and define stringification operators. And based on `-\u003eisa` you would know if passed object is string or bytearray representation.","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1579808745,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0NDA2MQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577844061"},"message":"In other words: there is no difference in implementation that can be used, so you need a difference in intent, specified by the user. This is why python 3 implemented this the way they did: two different string types.","files":null},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579808879,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0NDk4Mw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577844983"},"message":"\u003e sv_utf8_decode() leaves pure-ASCII strings alone\n...\n\u003e Unicode::UTF8 does add the flag\n\nAs you cannot distinguish between character and byte orientated data, Perl (and modules) can use any from those two internal representations for storing binary data. One is just less space effective, but both are correct. And if you use Perl's `eq` operator to compare them, it works correctly also when compatring scalars with different internal representation (Perl can convert between internal representation when needed automatically).","files":null},{"type":3,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579809245,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg0NzI1MQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577847251"},"message":"I’m aware that the only legitimate model for pure-Perl code is to regard all strings as sequences of code points in no particular encoding.\n\nThis is going off-topic, but if:\n- all decode()/encode() actions add/remove the flag, regardless of input\n- decode/encode() is the only way to add/remove the flag\n- interaction between flagged \u0026 non-flagged strings is always a failure\n\n… then we would effectively have two different string types.\n\nI got a proof-of-concept up a few weeks back of having perl throw if asked to concatenate flagged/non-flagged strings. It’ll need a lot more work to be truly demoable, though. I’m aware that this is not the intent of the UTF8 flag; my idea is that, given proper constraints, it can be _used_ that way.\n\nAnyway, even if that idea does eventually bear any fruit, it won’t affect this module.","files":null},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579809672,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg1MDUwNQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577850505"},"message":"\u003e but if:\n\u003e \n\u003e * all decode()/encode() actions add/remove the flag, regardless of input\n\u003e * decode/encode() is the only way to add/remove the flag\n\u003e * interaction between flagged \u0026 non-flagged strings is always a failure\n\nThis is not how Perl is working. Perl interpreter internally itself and any C/XS module can convert scalar to flagged (for faster Unicode operations, like regex matching) or non-flagged (for space efficienty).","files":null},{"type":3,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579809894,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzg1MjEwMw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-577852103"},"message":"@pali The idea is to use something like $^H to signal the interpreter whether to do the auto-conversions or to throw.\n```\n{\n    use typedstrings;\n\n    \"\\xff\" . \"\\x{100}\";    # throws\n}\n\n\"\\xff\" . \"\\x{100}\";    # lives\n```","files":null},{"type":3,"author":{"id":"5e0a68f2609f1b2ed53fa7449ddf2c976324fce4"},"timestamp":1579874808,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODE0Mzc4OA==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-578143788"},"message":"@FGasper This does not make sense, with this change you would break concatenation of English characters A-Z (part of ascii) with their accented characters like Á-Ž. Also this change would break concatenation of space with accepted character č.","files":null},{"type":3,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579875164,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODE0NTg3MQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158#issuecomment-578145871"},"message":"@pali It will work if the strings with ASCII characters have the UTF8 flag. That’s what Unicode::UTF8 does, so there’s precedent, though it’s not what sv_utf8_decode() does.\n\nSo something like:\n```\nuse typedstrings;\n\nmy $binary = readline;\nmy $chars = typedstrings::decode_utf8($binary);    # always does SvUTF8_on()\n\nmy $concat = $chars . \"Á-Ž\";    # works\n```\nThe idea is strict enforcement of what `perldoc perlunitut` prescribes—input, decode, handle, encode, output—so that any code that violates that will blow up, with an error that says exactly what’s wrong.","files":null},{"type":6,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1579875164,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MzI3OTQyOQ=="},"target":"c7833e2018ea40b14181e0d6ef34c1e9ce24f2283195c52936b2eb161dd38e7c","message":"@pali It will work if the strings with ASCII characters have the UTF8 flag. That’s what Unicode::UTF8’s decoder does, so there’s precedent, though it’s not what sv_utf8_decode() does.\n\nSo something like:\n```\nuse typedstrings;\n\nmy $binary = readline;\nmy $chars = typedstrings::decode_utf8($binary);    # always does SvUTF8_on()\n\nmy $concat = $chars . \"Á-Ž\";    # works\n```\nThe idea is strict enforcement of what `perldoc perlunitut` prescribes—input, decode, handle, encode, output—so that any code that violates that will blow up, with an error that says exactly what’s wrong.","files":null}]}