{"version":1,"ops":[{"type":1,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1447593576,"metadata":{"github-id":"MDU6SXNzdWUxMTY5OTIyMzI=","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/41","origin":"github"},"title":"stricter decode(\"true\") - should fail as nonref","message":"\"true\" (or \"false\") in decode(\"true\") or decode_json(\"true\") is not a reference, and therefore needs to fail.\ndecode needs allow_nonref to pass. At least my understanding is that **true**/**false** are no JSON objects, they are a primitive. Even \"null\" is not a valid JSON text/object.\n\n\u003e **$json-\u003eallow_nonref ([$enable])**\n\u003e If `$enable` is true (or missing), then the `encode` method can convert a\n\u003e non-reference into its corresponding string, number or null JSON value,\n\u003e which is an extension to RFC4627. **Likewise, `decode` will accept those JSON\n\u003e values instead of croaking.**\n\u003e \n\u003e If `$enable` is false, then the `encode` method will croak if it isn't\n\u003e passed an arrayref or hashref, as JSON texts must either be an object\n\u003e or array. **Likewise, `decode` will croak if given something that is not a\n\u003e JSON object or array.**\n\nConfirmed by the spec http://www.ietf.org/rfc/rfc4627.txt\n\n\u003e **2.  JSON Grammar**\n\u003e \n\u003e   A JSON text is a sequence of tokens.  The set of tokens includes six\n\u003e   structural characters, strings, numbers, and three literal names.\n\u003e \n\u003e   A JSON text is a serialized object or array.\n\u003e \n\u003e ```\n\u003e  JSON-text = object / array\n\u003e ```\n\u003e \n\u003e [...]\n\u003e \n\u003e **2.1.  Values**\n\u003e \n\u003e   A JSON value MUST be an object, array, number, or string, or one of\n\u003e   the following three literal names:\n\u003e \n\u003e ```\n\u003e  false null true\n\u003e ```\n\nSo the literal names are no objects. They are valid JSON values, but not a valid JSON text.\n\nThis is wrong in all perl JSON packages, but correct in ruby. php json_decode extends rfc4627 as our allow_nonref flags by allowing null, true and false.\n\nInterestingly the JSON::XS documentation and error message is spec conformant, just the implementation not. =\u003e decode_json(\"false\")\nJSON text must be an object or array (but found number, string, true, false or null, use allow_nonref to allow this)\n\nChanging the XS internal true/false SV from RV to the direct blessed object of JSON::PP::Boolean fixes this bug, and also enables eq overload.\npreviously we used a RV to the blessed PVMG JSON::PP::Boolean object.\nThe problem is with eq overloading, that eq needs the object directly,\nit will not call overload magic on the reference \u003c 5.16\n\nI work on this in the branch `nonrefbool-gh41` but a whole lot of hell broke loose with this change.\nMaybe just disable eq overload and keep the 3.0115 state.","files":null}]}