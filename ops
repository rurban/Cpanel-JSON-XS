{"version":1,"ops":[{"type":3,"author":{"id":"42b8049125821cad60d350df07d9d216b854f3f7"},"timestamp":1524428354,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4MzQwOTM2NQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/108#issuecomment-383409365"},"message":"filimonov \u003cnotifications@github.com\u003e schrieb am So., 22. Apr. 2018, 01:52:\n\n\u003e Currently if JSON::XS see that some scalar is stored internally only as\n\u003e number it never quotes that.\n\u003e\n\u003e But sometimes that quoting is desired, and currently the only workaround\n\u003e is to stringify all scalars before passing structure to JSON::XS. And that\n\u003e is a) another iteration through the data b) require modification/or copy of\n\u003e original data c) slow (can take even more time that converting to JSON).\n\u003e\nThat would be a major change. Can you describe the use case where are\nstringification is better than using numbers, and why using types doesn't\nhelp. By specifying the string type you have the same effect.\n\n\n\nSome similar questions on StackOverflow\n\u003e\n\u003e    -\n\u003e    https://stackoverflow.com/questions/29974529/perl-json-to-treat-all-numbers-as-string\n\u003e    -\n\u003e    https://stackoverflow.com/questions/17068764/why-does-the-json-module-quote-some-numbers-but-not-others\n\u003e    -\n\u003e    https://stackoverflow.com/questions/35227290/determining-if-a-perl-scalar-is-a-string-or-integer\n\u003e    etc.\n\u003e\n\u003e v1 of JSON had such a feature, check:\n\u003e http://search.cpan.org/~makamaka/JSON-1.15/lib/JSON.pm#AUTOCONVERT\n\u003e\n\u003e â€”\n\u003e You are receiving this because you are subscribed to this thread.\n\u003e Reply to this email directly, view it on GitHub\n\u003e \u003chttps://github.com/rurban/Cpanel-JSON-XS/issues/108\u003e, or mute the thread\n\u003e \u003chttps://github.com/notifications/unsubscribe-auth/AACjUXJPbNbg08EuFIQ_5JjRjIGd7dCfks5tq8Y3gaJpZM4Teqe9\u003e\n\u003e .\n\u003e","files":null},{"type":3,"author":{"id":"3e205196d38e1a64f390ea7b4e88d6b7deb6aa11"},"timestamp":1524436321,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4MzQxNzYxNw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/108#issuecomment-383417617"},"message":"\u003e That would be a major change. \n\nI thought it will be just adding quotes around (currenty) unquoted fields ;) So you don't need to play with quoting unsafe chars inside, as numbers can't have unsafe chars. You also don't need to implement any extra magic, just `if option enabled add quotes here and there`.  And I don't think that change should be generalized for **all** cases, it should be an **option** to quote (or not quote, like now) the numbers for some specific cases (when parser acceps quoted numbers, and does not accept unquoted strings).\n\nThe motivation is:  some parsers are sensetive on quoting, and perl does not have strict types, so the decision of \"to quote or not to quote\" is not always obvios/predictable.\n\nIn perl you can have a number that was used recently as a string (and will be quoted), or you can have a string field which has been created by numeric operation (and will not be quoted). So quoting strategy currenly depends only on the 'last operation kind' which is not predictable in general (so if last operation was numeric - number will be not quoted, if last operation was string - number will be quoted). \n\nCurrenly i have a situation when some specific JSON parser accepts only quoted format for strings, and both quoted/unquoted format for numbers. And i'm creating lib which can't predict the types of scalars which will be passed as an input (as i can't predict if scalar was created by numeric or string operation).\n\nOnce again:\n1) i'm creating a library, so i can't predict how the passed scalars was created - by numeric operation or by string operation.\n2) i know that parser that will parse the resulting JSON (written in C++) will not accept the string fields in unquoted format (even if they were calculated in perl as numeric values), and i know that parser can parse quoted numbers. \n3) so the safest strategy is to 'quote-all-around', but currently i can't force that during JSON encoding without stringifying everything around (which is slow and uneffecient)\n\nPS. actually the second good resolution of that problem is to change the target parser to allow unquoted numeric-looking strings in string fields. But still older version of that parser will not accept numbers as strings, and may be support for 'predictable' way of quoting should exists in Cpanel::JSON::XS itself (currently quoting depengs of type-sniffing. which can work bad in perl).\n\nPPS. the third good resolution is to force 'quoting strategy' for specific fields, but implementation of that can be quite painfull. \n\nPPPS. Test sample:\n```perl \nmy $perl_scalar = {  a =\u003e 10*100 };\nmy $coder = Cpanel::JSON::XS-\u003enew-\u003eascii-\u003eforce_numbers_quoting;\nis( $coder-\u003eencode ($perl_scalar), '{\"a\":\"1000\"}' );\n```","files":null},{"type":3,"author":{"id":"d19730b1d47a47ba43733401ca1bc3d2bbb7f976"},"timestamp":1524437888,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4MzQxOTAzNQ==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/108#issuecomment-383419035"},"message":"Note that in Cpanel::JSON::XS and JSON::PP, quoting is more predictable: numbers will not be quoted just because they were *used* as a string but only if they are created as a string. Did you consider the type schema solution mentioned? See https://metacpan.org/pod/Cpanel::JSON::XS::Type","files":null},{"type":3,"author":{"id":"3e205196d38e1a64f390ea7b4e88d6b7deb6aa11"},"timestamp":1524438285,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4MzQxOTM5Mw==","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/108#issuecomment-383419393"},"message":"\u003e Did you consider the type schema solution mentioned? See https://metacpan.org/pod/Cpanel::JSON::XS::Type\n\nSounds nice (i've called that 'the third good resolution' above), didn't know that this feature already exist. I'll check that, thanks.","files":null},{"type":4,"author":{"id":"3e205196d38e1a64f390ea7b4e88d6b7deb6aa11"},"timestamp":1524481888,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTU4ODg2OTg2MA=="},"status":2}]}