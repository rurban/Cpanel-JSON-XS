{"version":1,"ops":[{"type":1,"author":{"id":"9dd28cebd57feae3f8309d26ccdda3980b931ca5"},"timestamp":1498148884,"metadata":{"github-id":"MDU6SXNzdWUyMzc5MDIzNzc=","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/86","origin":"github"},"title":"double encoded UTF8 string","message":"dear owner/maintainer \n\nCpanel::JSON::XS version: 3.0233\nPerl 5.16 CentOS 7\n\n\nthis oneliner:\n\nbash# perl -e 'use Cpanel::JSON::XS(); $a = {a=\u003e\"JSON::XS - 正しくて高速な JSON シリアライザ/デシリアライザ\"}; print \u0026Cpanel::JSON::XS::encode_json($a)'\n\nhave result double encoded UTF8 :\n\n{\"a\":\"JSON::XS - æ­£ã��ã��ã�¦é«�é��ã�ª JSON ã�·ã�ªã�¢ã�©ã�¤ã�¶/ã��ã�·ã�ªã�¢ã�©ã�¤ã�¶\"}\n\nI try to patch XS.xs with some C code from:\n\nhttps://stackoverflow.com/questions/1031645/how-to-detect-utf-8-in-plain-c\nanswer no. 2\n\n//-------------------------------------------------\nchar already_utf8(const char * string)\n{\n    const unsigned char * bytes = (const unsigned char *)string;\n    if(!string)\n        return 0;\n\n    while(*bytes)\n    {\n        if( (// ASCII\n             // use bytes[0] \u003c= 0x7F to allow ASCII control characters\n                bytes[0] == 0x09 ||\n                bytes[0] == 0x0A ||\n                bytes[0] == 0x0D ||\n                (0x20 \u003c= bytes[0] \u0026\u0026 bytes[0] \u003c= 0x7E)\n            )\n        ) {\n            bytes += 1;\n            continue;\n        }\n\n        if( (// non-overlong 2-byte\n                (0xC2 \u003c= bytes[0] \u0026\u0026 bytes[0] \u003c= 0xDF) \u0026\u0026\n                (0x80 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0xBF)\n            )\n        ) {\n            bytes += 2;\n            continue;\n        }\n\n        if( (// excluding overlongs\n                bytes[0] == 0xE0 \u0026\u0026\n                (0xA0 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[2] \u0026\u0026 bytes[2] \u003c= 0xBF)\n            ) ||\n            (// straight 3-byte\n                ((0xE1 \u003c= bytes[0] \u0026\u0026 bytes[0] \u003c= 0xEC) ||\n                    bytes[0] == 0xEE ||\n                    bytes[0] == 0xEF) \u0026\u0026\n                (0x80 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[2] \u0026\u0026 bytes[2] \u003c= 0xBF)\n            ) ||\n            (// excluding surrogates\n                bytes[0] == 0xED \u0026\u0026\n                (0x80 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0x9F) \u0026\u0026\n                (0x80 \u003c= bytes[2] \u0026\u0026 bytes[2] \u003c= 0xBF)\n            )\n        ) {\n            bytes += 3;\n            continue;\n        }\n\n        if( (// planes 1-3\n                bytes[0] == 0xF0 \u0026\u0026\n                (0x90 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[2] \u0026\u0026 bytes[2] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[3] \u0026\u0026 bytes[3] \u003c= 0xBF)\n            ) ||\n            (// planes 4-15\n                (0xF1 \u003c= bytes[0] \u0026\u0026 bytes[0] \u003c= 0xF3) \u0026\u0026\n                (0x80 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[2] \u0026\u0026 bytes[2] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[3] \u0026\u0026 bytes[3] \u003c= 0xBF)\n            ) ||\n            (// plane 16\n                bytes[0] == 0xF4 \u0026\u0026\n                (0x80 \u003c= bytes[1] \u0026\u0026 bytes[1] \u003c= 0x8F) \u0026\u0026\n                (0x80 \u003c= bytes[2] \u0026\u0026 bytes[2] \u003c= 0xBF) \u0026\u0026\n                (0x80 \u003c= bytes[3] \u0026\u0026 bytes[3] \u003c= 0xBF)\n            )\n        ) {\n            bytes += 4;\n            continue;\n        }\n\n        return 0;\n    }\n\n    return 1;\n}\n//-------------------------------------------------\n\nthen at XS.xs function encode_sv line 1576\n\nI change:\n\n\n     encode_str (enc, str, len, SvUTF8 (sv));\n\nto\n\n     encode_str (aTHX_ enc, str, len, already_utf8(str) ? 1 : SvUTF8 (sv));\n\n\nthen try again:\n\n\nbash# perl -e 'use Cpanel::JSON::XS(); $a = {a=\u003e\"JSON::XS - 正しくて高速な JSON シリアライザ/デシリアライザ\"}; print \u0026Cpanel::JSON::XS::encode_json($a)'\n\nresult:\n\n{\"a\":\"JSON::XS - 正しくて高速な JSON シリアライザ/デシリアライザ\"}\n\nplease apply or fix in next release.\npatched source code attached \n[XS.xs.txt](https://github.com/rurban/Cpanel-JSON-XS/files/1095466/XS.xs.txt)\n\n\nsorry for my bad english,\nthx,\nasw","files":null}]}