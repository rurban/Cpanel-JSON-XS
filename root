{"version":1,"ops":[{"type":1,"author":{"id":"7cd73627a3d11a0df08c78285f581fae0cf6f6a6"},"timestamp":1578195739,"metadata":{"github-id":"MDU6SXNzdWU1NDUzNjQzMTU=","github-url":"https://github.com/rurban/Cpanel-JSON-XS/issues/158","origin":"github"},"title":"Require text input to be decoded?","message":"```\n\u003e perl -MCpanel::JSON::XS -MDevel::Peek -e'Dump( Cpanel::JSON::XS::encode_json([\"\\xff\"]) )'\nSV = PV(0x7ff76f004d30) at 0x7ff76f0159d0\n  REFCNT = 1\n  FLAGS = (TEMP,POK,pPOK)\n  PV = 0x7ff76ec3f2d0 \"[\\\"\\303\\277\\\"]\"\\0\n  CUR = 6\n  LEN = 34\n```\nIn an ideal world, `encode_json()` should throw here because, without a decode having happened on that input string, there’s no way to know what _character_ is intended with the `\\xff` in the string.\n\nInstead, the encoder “auto-decodes” the string as Latin-1, then outputs it as UTF-8. This seems wildly unintuitive and probably confuses a lot of people. It builds in an assumption that I want code point 255 in Latin-1; I could just as readily want point 255 in Latin-2 or some other character set. Or, perhaps more likely, I’m someone who thinks JSON can store a single 0xFF octet in a string. In either case, the exception would usefully force correct code: decode the string from raw bytes, _then_ encode it as JSON.\n\nI’m guessing Cpanel::JSON::XS is already too widely used for this to be its default mode of operation; however, perhaps a `strict()` mode could be added to reject byte strings given to `encode()`?","files":null}]}